{
  lib,
  flake-parts-lib,
  ...
}: let
  inherit (flake-parts-lib) mkPerSystemOption;
  inherit (lib) concatStringsSep mkOption types;

  mkNeovimEnv = {
    config,
    pkgs,
    ...
  }: let
    rtp = config.neovim.build.runtimepath; # -> packages[]
    rtp-before = concatStringsSep "," (map (p: "${p}") rtp);
    rtp-after = concatStringsSep "," (map (p: "${p}/after") rtp);

    init-lua = pkgs.writeTextFile {
      name = "init.lua";
      text = ''
        -- Generated by Nix (via github:willruggiano/neovim.nix)
        vim.opt.runtimepath = "${rtp-before},$VIMRUNTIME,${rtp-after}"

        -- TODO: This is a super simple approach?
        -- Why do we even need a neovim-nix lua module?
        vim.cmd.source "${config.neovim.build.vimOptions}"
        vim.cmd.source "${config.neovim.build.vimGlobals}"

        vim.cmd.source "${config.neovim.build.plugins}"
        -- TODO: Is there a lua way to do this?
        -- vim.cmd "set packpath^=''${config.neovim.build.packpath}"

        -- TODO: This might be a nicer interface?
        -- require("neovim-nix").setup {...}
        -- But for now...
        -- require "neovim-nix.options"
      '';
    };

    # TODO: Use wrapProgram?
    wrapper = pkgs.writeTextFile rec {
      name = "nvim";
      executable = true;
      destination = "/bin/${name}";
      text =
        ''
          #!${pkgs.runtimeShell}
          set -o errexit
          set -o nounset
          set -o pipefail
        ''
        + ''
          ${config.neovim.package}/bin/nvim --clean -u ${init-lua} "$@"
        '';

      checkPhase = ''
        runHook preCheck
        ${pkgs.stdenv.shellDryRun} "$target"
        ${pkgs.shellcheck}/bin/shellcheck "$target"
        runHook postCheck
      '';
    };
  in
    pkgs.buildEnv {
      name = "neovim-env";
      paths = [wrapper];
      meta.mainProgram = "nvim";
      passthru = {inherit init-lua;};
    };
in {
  imports = [
    {
      _module.args.neovim-lib = import ./lib.nix {inherit lib;};
    }
    ./neovim
    ./plugins
  ];

  options = {
    perSystem = mkPerSystemOption ({
      config,
      pkgs,
      ...
    }: {
      options = {
        neovim = {
          final = mkOption {
            type = types.package;
            description = "The final Neovim derivation, with all user configuration baked in";
          };
          init-lua = mkOption {
            type = types.package;
            description = "The final Neovim init.lua file";
          };
        };
      };

      config = {
        neovim = let
          final = mkNeovimEnv {inherit config pkgs;};
        in {
          inherit final;
          inherit (final) init-lua;
        };
      };
    });
  };
}
